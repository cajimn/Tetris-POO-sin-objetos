// Representación matricial de la pantalla.
int filas = 22;
int columnas = 12;

// Usar un ArrayList hace más facil la eliminación de filas completas
// Y añadir una nueva fila vacía al principio del tablero.
ArrayList<color[]> tablero = new ArrayList<color[]>();

// constantes: ancho y largo del cuadrado
float largo;
float ancho;

// Arrays usados para dibujar los tetrominos en sus
// respectivas rotaciones.
int [] T = {58368, 19520, 19968, 35968};
int [] Z = {50688, 19584, 50688, 19584};
int [] S = {27648, 35904, 27648, 35904};
int [] I = {3840 , 17476, 61440, 17476};
int [] O = {52224, 52224, 52224, 52224};
int [] L = {59392, 50240, 11776, 35008};
int [] J = {57856, 17600, 36352, 51328};

int [] figura;

int numFigura = (int)random (7);

// Rotacion inicial.
int tRotation = 2;
int pRotation = 1;

// posiciones de los cuadrados
int desplazamientoX = 4;
int desplazamientoY = 0;

float posX;
float posY;

// colores RGB.
color[] colores = {
            color(100),//Borde---0
            color(128, 12, 128), //purple---1
            color(230, 12, 12), //red-------2
            color(12, 230, 12), //green-----3
            color(9, 239, 230), //cyan------4
            color(230, 230, 9), //yellow----5
            color(230, 128, 9), //orange----6
            color(12, 12, 230)};//blue------7
            
color tColor = colores[int(random(1, 7))];

// contadores e Intervalos.
int timerPaso;
int intervaloPaso = 1000;
int timerFilaCompleta;
int intervaloFilaCompleta = 500;

// Fuente para letreros
PFont f;

// banderas
boolean gameOverBool = false;

void setup() {
  // pantalla 420x840 pixels.
  size(252, 504);
  ancho = width/columnas;
  largo = height/(filas-1);  

  // Inicializar tablero
  resetTablero();
  //println();
  //imprimirArrayList();

  // Crear fuente para tableros.
  //printArray(PFont.list());
  f = createFont("Consolas Bold", 24);
}

void draw() {
  background(125);
  
  if (!gameOverBool) {
    drawTablero();
    drawTetromino(numFigura);
    if (millis() - timerPaso >= intervaloPaso) {
      darPaso();
      timerPaso = millis();
    }

    if (millis() - timerFilaCompleta >= intervaloFilaCompleta) {
      filasCompletas();
      timerFilaCompleta = millis();
    }
  } else {
    drawTablero();
    gameOver();
  }
}


void drawTetromino(int numero) {
  switch (numero) {
  case 0:
      fill(colores[1],100);
      figura = T;      
      break;
    case 1:
      fill(colores[2],100);
      figura = Z;
      break;
    case 2:
      fill(colores[3],100);
      figura = S;
      break;
    case 3:
      fill(colores[4],100);
      figura = I;
      break;
    case 4:
      fill(colores[5],100);
      figura = O;
      break;
    case 5:
      fill(colores[6],100);
      figura = L;
      break;
    case 6:
      fill(colores[7],100);
      figura = J;
      break;      
  }

  push();
  translate(0, -largo);
  strokeWeight(2);
  //fill(tColor);
  for (int i = 0; i <= 15; i++) {
    if ((figura[tRotation] & (1 << 15 - i)) != 0) {
      posX = (i%4)*ancho + desplazamientoX*ancho;
      posY = ((i/4)|0) * largo + desplazamientoY*largo;
      rect(posX, posY, ancho, largo,4);
    } /*else {
     posX = (i%4)*ancho + desplazamientoX*ancho;
     posY = ((i/4)|0) * largo + desplazamientoY*largo;
     push();
     fill(colores[0]);
     rect(posX, posY, ancho, largo);
     pop();
     }*/
  }
  pop();
}

void drawTablero() {
  push();
  stroke(0);
  strokeWeight(2);
  translate(0, -largo);
  for (int i=0; i < filas; i++) {
    push();
    stroke(0);
    strokeWeight(1);
    line(0, i*largo, width, i*largo);
    pop();
    for (int j=0; j < columnas; j++) {
      push();
      stroke(0);
      strokeWeight(1);
      line(j*ancho, 0, j*ancho, height);
      pop();
      if (j == 0 || j == columnas - 1 || i == filas - 1) {
        fill(colores[0]);
        rect(j*ancho, i*largo, ancho, largo,4);
      } else if (tablero.get(i)[j] != 0) {
        fill(tablero.get(i)[j]);
        rect(j*ancho, i*largo, ancho, largo,4);
      }
    }
  }
  pop();
}

void keyPressed() {
  if (!gameOverBool) {
    if (key == 'a' || keyCode == LEFT) {
      if (!colisionIzquierda()) desplazamientoX--;
    } else if (key == 'd' || keyCode == RIGHT) {
      if (!colisionDerecha()) desplazamientoX++;
    } else if (key == 's' || keyCode == DOWN) {
      if (!colisionAbajo()) darPaso();
    } else if (key == 'w' || keyCode == UP) {
      pRotation = tRotation;
      tRotation = (tRotation + 1)%4;
      // Agregada esta condición para evitar bugs en las rotaciones cerca de un borde.
      if (colisionRotacion()) tRotation = pRotation;
    }
  } else {
    if (keyCode == ENTER) {
      resetTablero();
      resetVariables();
    }
  }
}

boolean colisionIzquierda() {
  int posMX;
  int posMY;
  for (int j = 0; j < 4; j++)
  {
    for (int i = j; i < 16; i += 4) {
      if ((figura[tRotation] & (1 << 15 - i)) != 0) {
        posMX = (i%4) + desplazamientoX;
        posMY = ((i/4)|0) + desplazamientoY;
        if (tablero.get(posMY)[posMX-1] != 0)
          return true;
      }
    }
  }
  return false;
}

boolean colisionDerecha() {
  int posMX;
  int posMY;
  for (int j = 0; j < 4; j++)
  {
    for (int i = j; i < 16; i += 4) {
      if ((figura[tRotation] & (1 << i)) != 0) {
        posMX = ((15-i)%4) + desplazamientoX;
        posMY = (((15-i)/4)|0) + desplazamientoY;
        if (tablero.get(posMY)[posMX+1] != 0)
          return true;
      }
    }
  }
  return false;
}

boolean colisionAbajo() {
  int posMX;
  int posMY;
  for (int i = 0; i < 16; i ++) {
    if ((figura[tRotation] & (1 << i)) != 0) {
      posMX = ((15-i)%4) + desplazamientoX;
      posMY = (((15-i)/4)|0) + desplazamientoY;
      if (tablero.get(posMY+1)[posMX] != 0) {
        return true;
      }
    }
  }
  return false;
}

boolean colisionRotacion() {
  int posMX;
  int posMY;
  for (int i = 0; i <= 15; i++) {
    if ((figura[tRotation] & (1 << 15 - i)) != 0) {
      posMX = (i%4) + desplazamientoX;
      posMY = ((i/4)|0) + desplazamientoY;
      if (tablero.get(posMY)[posMX] != 0) return true;
    }
  }
  return false;
}

void siguienteFigura() {
  int posMX;
  int posMY;
  for (int i = 0; i <= 15; i++) {
    if ((figura[tRotation] & (1 << 15 - i)) != 0) {
      posMX = (i%4) + desplazamientoX;
      posMY = ((i/4)|0) + desplazamientoY;
      tablero.get(posMY)[posMX] = colores[numFigura+1];
    }
  }
  resetVariables();
}

void darPaso() {
  if (!colisionAbajo()) {
    desplazamientoY++;
  } else {
    int i;
    for (i = 1; i < columnas - 1 && tablero.get(1)[i] == 0; i++) {
    }
    gameOverBool = i < (columnas - 1);
    if (!gameOverBool) siguienteFigura();
  }
}

void filasCompletas() {
  for (int i = filas - 2; i >= 0; i--) {
    int j = 0;
    for (j = 1; j < 11 && tablero.get(i)[j] != 0; j++) {
    }
    if (j == 11) {
      tablero.remove(i);
      tablero.add(0, new color[columnas]);
      tablero.get(0)[0] = colores[0];
      tablero.get(0)[columnas-1] = colores[0];
    }
  }
}

void gameOver() {
  push();
  translate(width/2, height/2);
  textFont(f);
  textAlign(CENTER, CENTER);

  stroke(0);
  strokeWeight(5);
  fill(255,255,0);
  rectMode(CENTER);
  rect(0, 4, 240, 70,10);

  fill(40);
  textSize(35);
  text("GAME OVER", 0, 0);

  fill(0,0,255);
  textSize(34);
  text("GAME OVER", 0, 0);

  pop();
}

void resetTablero() {
  tablero = new ArrayList<color[]>();
  // ArrayList de arrays con ceros en sus elementos.
  for (int k = 0; k < filas; k++) {
    tablero.add(new color[columnas]);
  }
  //imprimirArrayList();
  for (int i = 0; i < filas; i++) {
    for (int j = 0; j < columnas; j++) {
      if (j == 0 || j == columnas - 1 || i == filas - 1)
        tablero.get(i)[j] = colores[0];
    }
  }
}

void resetVariables() {
  numFigura = (int) random (7);
  tColor = colores[int(random(1, 7))];
  tRotation = 2;
  desplazamientoX = 4;
  desplazamientoY = 0;
  gameOverBool = false;
  timerPaso = millis();
  timerFilaCompleta = millis();
}

void imprimirArrayList() {
  for (int i = 0; i < filas; i++) {
    for (int j = 0; j < columnas; j++) {
      print(tablero.get(i)[j] + " ");
    }
    println();
  }
}
